from __future__ import annotations

from datetime import timedelta
from typing import Any

from django.db import transaction
from django.utils import timezone

from api.models import (
    Appointment,
    ClinicalAlert,
    CommunityResource,
    DomainEvent,
    Patient,
    ResourceReferral,
    WorkflowRule,
)


RESERVED_CONDITION_KEYS = {'all', 'any', 'none'}


def _resolve_path(payload: dict[str, Any], path: str, default: Any = None) -> Any:
    current: Any = payload
    for key in path.split('.'):
        if isinstance(current, dict):
            current = current.get(key)
        else:
            return default
        if current is None:
            return default
    return current


def _as_bool(value: Any) -> bool:
    if isinstance(value, bool):
        return value
    if isinstance(value, str):
        return value.lower() in {'1', 'true', 'yes', 'on'}
    return bool(value)


def _evaluate_clause(payload: dict[str, Any], clause: dict[str, Any]) -> bool:
    if 'field' in clause:
        field = clause.get('field')
        op = clause.get('op', 'eq')
        expected = clause.get('value')
        actual = _resolve_path(payload, field)
    else:
        if len(clause) != 1:
            return False
        field, expected = next(iter(clause.items()))
        op = 'eq'
        actual = _resolve_path(payload, field)

    if op == 'eq':
        return actual == expected
    if op == 'ne':
        return actual != expected
    if op == 'in':
        return actual in (expected or [])
    if op == 'not_in':
        return actual not in (expected or [])
    if op == 'gte':
        return actual is not None and expected is not None and actual >= expected
    if op == 'gt':
        return actual is not None and expected is not None and actual > expected
    if op == 'lte':
        return actual is not None and expected is not None and actual <= expected
    if op == 'lt':
        return actual is not None and expected is not None and actual < expected
    if op == 'contains':
        return expected is not None and actual is not None and str(expected).lower() in str(actual).lower()
    if op == 'exists':
        return (actual is not None) == _as_bool(expected)
    return False


def rule_matches_event(rule: WorkflowRule, payload: dict[str, Any]) -> bool:
    condition = rule.condition or {}
    if not condition:
        return True

    if not (set(condition.keys()) & RESERVED_CONDITION_KEYS):
        return all(payload.get(key) == value for key, value in condition.items())

    all_clauses = condition.get('all', [])
    any_clauses = condition.get('any', [])
    none_clauses = condition.get('none', [])

    all_ok = all(_evaluate_clause(payload, clause) for clause in all_clauses) if all_clauses else True
    any_ok = any(_evaluate_clause(payload, clause) for clause in any_clauses) if any_clauses else True
    none_ok = not any(_evaluate_clause(payload, clause) for clause in none_clauses) if none_clauses else True
    return all_ok and any_ok and none_ok


def _render_template(template: str, payload: dict[str, Any], fallback: str) -> str:
    if not template:
        return fallback
    try:
        return template.format(**payload)
    except Exception:
        return template


def _resolve_config_value(config: dict[str, Any], key: str, payload: dict[str, Any], default: Any = None) -> Any:
    raw = config.get(key, default)
    if isinstance(raw, dict) and 'from_payload' in raw:
        payload_value = _resolve_path(payload, raw['from_payload'], raw.get('default'))
        return payload_value if payload_value is not None else default
    return raw


def _execute_create_alert(rule: WorkflowRule, payload: dict[str, Any]) -> int:
    config = rule.action_config or {}
    patient_id = _resolve_config_value(config, 'patient_id', payload, payload.get('patient_id'))
    if not patient_id:
        raise ValueError('create_alert requires patient_id in event payload or action_config.')
    patient = Patient.objects.get(pk=patient_id)

    severity = _resolve_config_value(config, 'severity', payload, ClinicalAlert.SEVERITY_HIGH)
    title = _render_template(
        _resolve_config_value(config, 'title', payload, ''),
        payload,
        f'Workflow alert from {rule.name}',
    )
    message = _render_template(
        _resolve_config_value(config, 'message', payload, ''),
        payload,
        f'Automated alert generated by workflow rule "{rule.name}".',
    )

    alert = ClinicalAlert.objects.create(
        patient=patient,
        severity=severity,
        title=title,
        message=message,
    )
    return alert.id


def _execute_create_appointment(rule: WorkflowRule, payload: dict[str, Any]) -> int:
    config = rule.action_config or {}
    patient_id = _resolve_config_value(config, 'patient_id', payload, payload.get('patient_id'))
    if not patient_id:
        raise ValueError('create_appointment requires patient_id in event payload or action_config.')
    patient = Patient.objects.get(pk=patient_id)

    scheduled_in_hours = int(_resolve_config_value(config, 'scheduled_in_hours', payload, 24))
    scheduled_at = timezone.now() + timedelta(hours=scheduled_in_hours)
    clinician_name = _resolve_config_value(config, 'clinician_name', payload, 'Care Team')
    reason = _render_template(
        _resolve_config_value(config, 'reason', payload, ''),
        payload,
        f'Automated follow-up from workflow rule "{rule.name}".',
    )

    appointment = Appointment.objects.create(
        patient=patient,
        clinician_name=clinician_name,
        reason=reason,
        scheduled_at=scheduled_at,
        status=Appointment.STATUS_SCHEDULED,
        created_by=rule.created_by,
    )
    return appointment.id


def _execute_create_referral(rule: WorkflowRule, payload: dict[str, Any]) -> int:
    config = rule.action_config or {}
    patient_id = _resolve_config_value(config, 'patient_id', payload, payload.get('patient_id'))
    if not patient_id:
        raise ValueError('create_referral requires patient_id in event payload or action_config.')
    patient = Patient.objects.get(pk=patient_id)

    resource_id = _resolve_config_value(config, 'resource_id', payload)
    resource = None
    if resource_id:
        resource = CommunityResource.objects.filter(pk=resource_id, active=True).first()
    if not resource:
        category = _resolve_config_value(config, 'resource_category', payload)
        if category:
            resource = CommunityResource.objects.filter(active=True, category=category).order_by('id').first()
    if not resource:
        raise ValueError('create_referral requires resource_id or resource_category with an active resource.')

    reason = _render_template(
        _resolve_config_value(config, 'reason', payload, ''),
        payload,
        f'Automated referral generated by workflow rule "{rule.name}".',
    )
    status = _resolve_config_value(config, 'status', payload, ResourceReferral.STATUS_RECOMMENDED)
    referral = ResourceReferral.objects.create(
        patient=patient,
        resource=resource,
        referred_by=rule.created_by,
        reason=reason,
        status=status,
    )
    return referral.id


def execute_rule_action(rule: WorkflowRule, payload: dict[str, Any]) -> dict[str, Any]:
    if rule.action_type == WorkflowRule.ACTION_CREATE_ALERT:
        created_id = _execute_create_alert(rule, payload)
    elif rule.action_type == WorkflowRule.ACTION_CREATE_APPOINTMENT:
        created_id = _execute_create_appointment(rule, payload)
    elif rule.action_type == WorkflowRule.ACTION_CREATE_REFERRAL:
        created_id = _execute_create_referral(rule, payload)
    else:
        raise ValueError(f'Unsupported action_type: {rule.action_type}')

    return {
        'rule_id': rule.id,
        'rule_name': rule.name,
        'action_type': rule.action_type,
        'created_id': created_id,
    }


def process_domain_event(event: DomainEvent) -> dict[str, Any]:
    payload = event.payload or {}
    event.attempts += 1
    event.save(update_fields=['attempts'])

    try:
        with transaction.atomic():
            matched_actions: list[dict[str, Any]] = []
            rules = WorkflowRule.objects.filter(
                active=True,
                event_type=event.event_type,
            ).order_by('priority', 'id')
            for rule in rules:
                if rule_matches_event(rule, payload):
                    matched_actions.append(execute_rule_action(rule, payload))

        event.status = DomainEvent.STATUS_PROCESSED
        event.error_message = ''
        event.processed_at = timezone.now()
        event.save(update_fields=['status', 'error_message', 'processed_at'])
        return {
            'event_id': event.id,
            'status': event.status,
            'matched_actions': matched_actions,
            'error': '',
        }
    except Exception as exc:
        event.status = DomainEvent.STATUS_FAILED
        event.error_message = str(exc)[:2000]
        event.processed_at = timezone.now()
        event.save(update_fields=['status', 'error_message', 'processed_at'])
        return {
            'event_id': event.id,
            'status': event.status,
            'matched_actions': [],
            'error': event.error_message,
        }


def emit_domain_event(
    event_type: str,
    payload: dict[str, Any],
    source: str = '',
    auto_process: bool = True,
) -> DomainEvent:
    event = DomainEvent.objects.create(event_type=event_type, source=source, payload=payload or {})
    if auto_process:
        process_domain_event(event)
    return event


def process_pending_domain_events(
    limit: int = 25,
    include_failed: bool = False,
    max_attempts: int = 3,
) -> dict[str, Any]:
    statuses = [DomainEvent.STATUS_PENDING]
    if include_failed:
        statuses.append(DomainEvent.STATUS_FAILED)

    queryset = DomainEvent.objects.filter(status__in=statuses, attempts__lt=max_attempts).order_by('occurred_at')[:limit]
    results = [process_domain_event(event) for event in queryset]

    return {
        'processed_count': sum(1 for item in results if item['status'] == DomainEvent.STATUS_PROCESSED),
        'failed_count': sum(1 for item in results if item['status'] == DomainEvent.STATUS_FAILED),
        'results': results,
    }
